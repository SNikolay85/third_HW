
\n Новая строка
.  Любой символ, кроме символа новой строки. Если flags=re.DOTALL - любой символ.
\s Любой символ пробела, табуляции или новой строки.
\S Любой символ, кроме пробела, табуляции или новой строки.
\d Любая цифра. Ищет все цифры: арабские, персидские, индийские, и так далее. Не эквивалентен [0-9]
\D Любой символ, кроме цифр.
\w Любая буква, цифра, или _. Шаблон не соответствует выражению [a-zA-Z0-9_]! Буквы используются не только латинские, туда входит множество языков.
\W Любой символ, кроме букв, цифр, и _.
\b Промежуток между символом, совпадающим с \w, и символом, не совпадающим с \w в любом порядке.
\B Промежуток между двумя символами, совпадающими с \w или \W.
\A Начало всего текста
\Z Конец всего текста
^  Начало всего текста или начало строчки текста, если flags=re.MULTILINE
$  Конец всего текста или конец строчки текста, если flags=re.MULTILINE

\r carriage return или CR, символ Юникода U+240D.
\t Tab символ
\0 null, символ Юникода U+2400.
\v Вертикальный пробел в Юникоде
\xYY 8-битный символ с заданным шестнадцатеричным значением.
Таблица юникода
Например \x2A находит символ *.

\ddd 8-битный символ с заданным восьмеричным значением. 
Таблица UTF-8
Например \052 находит символ *.

[\b] Символ backspace или BS. В скобках, т.к. \b уже занято другим спецсимволом.
\f Символ разрыва страницы.

Ленивые квантификаторы

{m,n}? - от m до n
{,n}? - до n
{m,}? - от m
*? - от 0
+? - от 1
?? - от 0 до 1

Каждый из этих квантификаторов будет пытаться захватить как можно меньше символов.

Жадные квантификаторы:

{m,n}
{,n}
{m,}
*
+
?

(?<!{шаблон}){выражение} - Проверяет, что {шаблон} не стоит перед {выражением}.
(?<={шаблон}){выражение} - Проверяет, что шаблон стоит перед выражением.
{выражение}(?={шаблон})  - Проверяет, что шаблон стоит после выражения.
{выражение}(?!{шаблон})  - Проверяет, что шаблон не стоит после выражения.
p.s.: шаблоном и выражением может быть регулярка

(?:regex) Позволяет группировать шаблоны.
(?#regex) Позволяет писать комментарии в регулярных выражениях.



(regex)	Обыкновенная скобочная группа. Захватывает символы, о которых можно будет получить более подробную информацию.

(?P<name>regex)	Обычная скобочная группа, но вместе с номером ей будет присвоено имя name.

(?P<name>regex)(?P=name) Скобочная группа с именем позволяет к ней обращаться и искать такой же текст, который она захватила.


regex = r"(a)?(?(1)b|c)"

# Группа (a)? ищет букву a. К группе применён квантификатор ?, т.к. этой буквы может не быть в тексте
# Если в первой группе нашлась буква a, то условие (?(1)b|c) ищет букву b
# Если первая группа ничего не нашла, то условие ищет букву c

# В данном примере регулярное выражение найдёт все ab и c в тексте